#!/usr/bin/env python3
""" 
This script has been generated by AI with minor tweaks from the author

This script compiles assembly instructions for the co-processor into machine code
This script is called by compile_nasm_to_header.py
"""

import sys


def assemble_nop(tokens):
    """
    NOP instruction format:
      12-bit don't care (filled with 0) | 4-bit opcode (0000)
    """
    bits = "000000000000" + "0000"
    hex_instr = format(int(bits, 2), '04X')
    return hex_instr


def assemble_ena(tokens):
    """
    ENA instruction format:
      Fixed 16-bit pattern: 0000 0000 0001 0000
    Assembly format: "ENA"
    """
    bits = "0000000000010000"
    hex_instr = format(int(bits, 2), '04X')
    return hex_instr


def assemble_baincr(tokens):
    """
    BAINCR instruction format:
      4-bit RS2 | 1-bit Disable if Zero | 5-bit X | 2-bit BA index | 4-bit opcode (0010)
    Assembly format: "BAINCR B<ba_index> <disable_flag> R<rs2>"
    Example: "BAINCR B0 D R5" -> 0101 1000 0000 0010
             "BAINCR B1 E R6" -> 0110 0000 0001 0010
    """
    if len(tokens) != 4:
        raise ValueError(
            "BAINCR instruction requires exactly 3 arguments: BA_index, disable_flag, register")

    ba_token = tokens[1]
    disable_flag = tokens[2]
    rs2_token = tokens[3]

    # Parse BA index
    if not ba_token.startswith('B'):
        raise ValueError("Invalid BA index format: " + ba_token)
    ba_index = int(ba_token[1:])
    if ba_index < 0 or ba_index > 3:
        raise ValueError("BA index must be 0-3: " + str(ba_index))

    # Parse disable flag
    if disable_flag.upper() == 'D':
        disable_bit = 1
    elif disable_flag.upper() == 'E':
        disable_bit = 0
    else:
        raise ValueError(
            "Disable flag must be 'D' (disable) or 'E' (enable): " + disable_flag)

    # Parse RS2 register
    if not rs2_token.startswith('R'):
        raise ValueError("Invalid register format: " + rs2_token)
    rs2_val = int(rs2_token[1:])
    if rs2_val < 0 or rs2_val > 15:
        raise ValueError("Register must be 0-15: " + str(rs2_val))

    # Build the instruction
    rs2_bin = format(rs2_val, '04b')
    disable_bin = format(disable_bit, '01b')
    x_bin = "00000"  # 5-bit X field (set to 0 as per examples)
    ba_index_bin = format(ba_index, '02b')
    opcode = "0010"

    bits = rs2_bin + disable_bin + x_bin + ba_index_bin + opcode
    hex_instr = format(int(bits, 2), '04X')
    return hex_instr


def assemble_branch(tokens):
    """
    Branch instruction format:
      8-bit instruction address | 4-bit loop id | 4-bit opcode (1000)
    Assembly format: "BRANCH IX LY" (e.g. "BRANCH I5 L2")
    """
    addr_token = tokens[1]
    loop_token = tokens[2]

    if not addr_token.startswith('I'):
        raise ValueError("Invalid branch address format: " + addr_token)
    if not loop_token.startswith('L'):
        raise ValueError("Invalid branch loop id format: " + loop_token)

    instruction_address = int(addr_token[1:])
    loop_id = int(loop_token[1:])

    inst_addr_bin = format(instruction_address, '08b')
    loop_id_bin = format(loop_id, '04b')
    opcode = "1000"

    bits = inst_addr_bin + loop_id_bin + opcode
    hex_instr = format(int(bits, 2), '04X')
    return hex_instr


def assemble_read(tokens):
    """
    Read from memory instruction format:
      5-bit relative address | 3-bit base address pointer |
      4-bit destination register | 4-bit opcode (0100)
    Assembly format: "READ R<dest> B<base>(<rel_addr>)" (e.g. "READ R3 B2(6)")
    """
    dest_reg = tokens[1]
    mem_operand = tokens[2]

    if not dest_reg.startswith('R'):
        raise ValueError("Invalid destination register: " + dest_reg)
    dest_reg_val = int(dest_reg[1:])

    if not mem_operand.startswith('B'):
        raise ValueError("Invalid memory operand in READ: " + mem_operand)
    lparen = mem_operand.find('(')
    rparen = mem_operand.find(')')
    if lparen == -1 or rparen == -1:
        raise ValueError("Invalid memory operand format: " + mem_operand)

    base_ptr_val = int(mem_operand[1:lparen])
    rel_addr = int(mem_operand[lparen+1:rparen])  # Multiply by 2 as required.

    rel_addr_bin = format(rel_addr, '05b')
    base_ptr_bin = format(base_ptr_val, '03b')
    dest_reg_bin = format(dest_reg_val, '04b')
    opcode = "0100"

    bits = rel_addr_bin + base_ptr_bin + dest_reg_bin + opcode
    hex_instr = format(int(bits, 2), '04X')
    return hex_instr


def assemble_write(tokens):
    """
    Write to memory instruction format:
      4-bit source register address | 1-bit MSB of relative address |
      3-bit base address pointer | 4-bit LSB of relative address | 4-bit opcode (1100)
    Assembly format: "WRITE B<base>(<rel_addr>) R<source>" (e.g. "WRITE B2(6) R5")
    """
    mem_operand = tokens[1]
    source_reg = tokens[2]

    if not source_reg.startswith('R'):
        raise ValueError("Invalid source register in WRITE: " + source_reg)
    source_reg_val = int(source_reg[1:])

    if not mem_operand.startswith('B'):
        raise ValueError("Invalid memory operand in WRITE: " + mem_operand)
    lparen = mem_operand.find('(')
    rparen = mem_operand.find(')')
    if lparen == -1 or rparen == -1:
        raise ValueError(
            "Invalid memory operand format in WRITE: " + mem_operand)

    base_ptr_val = int(mem_operand[1:lparen])
    rel_addr = int(mem_operand[lparen+1:rparen])

    rel_addr_bin = format(rel_addr, '05b')  # 5 bits
    msb = rel_addr_bin[0]
    lsb = rel_addr_bin[1:]

    source_reg_bin = format(source_reg_val, '04b')
    base_ptr_bin = format(base_ptr_val, '03b')
    opcode = "1100"

    bits = source_reg_bin + msb + base_ptr_bin + lsb + opcode
    hex_instr = format(int(bits, 2), '04X')
    return hex_instr


def assemble_arithmetic(tokens):
    """
    Arithmetic instructions (ADD, MUL, MAX, SHIFT) format:
      4-bit source register 2 | 4-bit source register 1 |
      4-bit destination register | 4-bit opcode
    Assembly format: "OP R<dest> R<op1> R<op2>" where the machine places op2 first.
    Opcodes:
      ADD   --> 0001
      MUL   --> 0011
      MAX   --> 0111
      SHIFT --> 1001
    """
    dest_reg = tokens[1]
    op1 = tokens[2]
    op2 = tokens[3]

    for reg in (dest_reg, op1, op2):
        if not reg.startswith('R'):
            raise ValueError(
                "Invalid register in arithmetic instruction: " + reg)

    dest_num = int(dest_reg[1:])
    op1_num = int(op1[1:])
    op2_num = int(op2[1:])

    # The machine code places the second operand first.
    op2_bin = format(op2_num, '04b')
    op1_bin = format(op1_num, '04b')
    dest_bin = format(dest_num, '04b')

    instr = tokens[0].upper()
    if instr == 'ADD':
        opcode = "0001"
    elif instr == 'MUL':
        opcode = "0011"
    elif instr == 'MAX':
        opcode = "0111"
    elif instr == 'SHIFT':
        opcode = "1001"
    else:
        raise ValueError("Unsupported arithmetic operation: " + instr)

    bits = op2_bin + op1_bin + dest_bin + opcode
    hex_instr = format(int(bits, 2), '04X')
    return hex_instr


def process_line(line):
    """
    Processes one assembly instruction line.
    Lines that do not start with a recognized keyword (or config directive) are ignored.
    """
    line = line.strip()
    if not line:
        return None

    # For assembly instructions, split tokens by whitespace and dispatch by keyword.
    tokens = line.split()
    operation = tokens[0].upper()

    # If the line is one of our assembly instructions, process it:
    if operation == 'NOP':
        return assemble_nop(tokens)
    elif operation == 'ENA':
        return assemble_ena(tokens)
    elif operation == 'BAINCR':
        return assemble_baincr(tokens)
    elif operation == 'BRANCH':
        return assemble_branch(tokens)
    elif operation == 'READ':
        return assemble_read(tokens)
    elif operation == 'WRITE':
        return assemble_write(tokens)
    elif operation in ['ADD', 'MUL', 'MAX', 'SHIFT']:
        return assemble_arithmetic(tokens)
    else:
        # Unsupported assembly instruction (or config line) are ignored here.
        return None


def compile_extended_nasm(input_file, output_file):
    """
    Extended compilation process which:
      1. Processes configuration directives at the beginning:
         - Base Address Increments (BAIT): paired and combined by shifting the second by 16 bits.
         - Loop Conditions (LCL): paired with the second shifted by 10 bits.
         - Task Addresses (TAT): four addresses with shifts of 0,8,16, and 24 bits.
      2. Processes assembly instructions and collects 16-bit machine codes.
      3. Combines every two 16-bit assembly instructions into a single 32-bit word.
         (If there is an odd number, a NOP is appended.)
      4. Writes out all configuration words (as 32-bit hex numbers) first,
         then the assembly words.
    """
    base_addr_increments = []  # Values for BAIT lines.
    loop_conditions = []       # Values for LCL lines.
    # Values for TAT lines (expected to be 4 values).
    task_addresses = []
    assembly_instrs = []       # 16-bit instructions from assembly lines.

    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue  # Skip empty and comment lines.

            # Process configuration lines first.
            if line.startswith("BAIT"):
                # Expect format: BAIT{...} <value>
                parts = line.split()
                if len(parts) != 2:
                    raise ValueError(
                        "Invalid BAIT configuration line: " + line)
                value = int(parts[1])
                base_addr_increments.append(value)
                continue
            elif line.startswith("LCL"):
                parts = line.split()
                if len(parts) != 2:
                    raise ValueError("Invalid LCL configuration line: " + line)
                value = int(parts[1])
                loop_conditions.append(value)
                continue
            elif line.startswith("TAT"):
                parts = line.split()
                if len(parts) != 2:
                    raise ValueError("Invalid TAT configuration line: " + line)
                value = int(parts[1])
                task_addresses.append(value)
                continue

            # Otherwise, assume it's an assembly instruction.
            machine_instr = process_line(line)
            if machine_instr is not None:
                assembly_instrs.append(machine_instr)

    config_words = []

    # Process base address increments.
    if len(base_addr_increments) % 2 != 0:
        raise ValueError("Odd number of base address increments provided.")
    for i in range(0, len(base_addr_increments), 2):
        low = base_addr_increments[i]
        high = base_addr_increments[i + 1]

        low16 = low & 0xFFFF
        high16 = high & 0xFFFF

        # Combine: lower value in low-order 16 bits, second shifted left by 16.
        # combined = (high << 16) | (low & 0xFFFF)
        # config_words.append(format(combined, '08X'))
        combined32 = ((high16 << 16) | low16) & 0xFFFFFFFF
        config_words.append(f'{combined32:08X}')

    # Process loop conditions.
    if len(loop_conditions) % 2 != 0:
        raise ValueError("Odd number of loop conditions provided.")
    for i in range(0, len(loop_conditions), 2):
        low = loop_conditions[i]
        high = loop_conditions[i + 1]
        # Combine: lower value in lower bits; second shifted left by 10.
        combined = (high << 10) | (low & ((1 << 10) - 1))
        config_words.append(format(combined, '08X'))

    # Process task addresses.
    if len(task_addresses) != 4:
        raise ValueError(
            "Expected 4 task address values, got " + str(len(task_addresses)))
    # Each value is shifted by a multiple of 8 bits: first << 0, second << 8, third << 16, fourth << 24.
    combined_tasks = (task_addresses[3] << 24) | (task_addresses[2] << 16) | (
        task_addresses[1] << 8) | task_addresses[0]
    config_words.append(format(combined_tasks, '08X'))

    # Combine assembly instructions into 32-bit words.
    asm_words = []
    # Append a NOP if we have an odd number of 16-bit instructions.
    if len(assembly_instrs) % 2 != 0:
        nop_instr = assemble_nop(["NOP"])
        assembly_instrs.append(nop_instr)
    for i in range(0, len(assembly_instrs), 2):
        # First instruction goes to lower 16 bits; second one to upper 16 bits.
        lower = int(assembly_instrs[i], 16)
        upper = int(assembly_instrs[i+1], 16)
        combined = (upper << 16) | lower
        asm_words.append(format(combined, '08X'))

    # Write the resulting 32-bit words to the output file.
    # First, the configuration words, then the combined assembly words.
    with open(output_file, 'w') as f:
        for word in config_words:
            f.write(word + "\n")
        for word in asm_words:
            f.write(word + "\n")


if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python pseudo_compiler.py input.nasm output.hex")
        sys.exit(1)

    in_file = sys.argv[1]
    out_file = sys.argv[2]
    compile_extended_nasm(in_file, out_file)
