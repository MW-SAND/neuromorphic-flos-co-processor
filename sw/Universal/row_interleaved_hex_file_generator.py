#!/usr/bin/env python3
""" 
This script has been generated by AI with minor tweaks from the author

This script converts a cheader into hex files with the appropriate number of interleaved rows and padding 
"""

import re
import os
import argparse
from typing import List, Dict, Tuple


class ArrayInfo:
    def __init__(self, name: str, dtype: str, values: List[int]):
        self.name = name
        # Strip const and _t if present
        self.dtype = dtype.replace("const ", "").replace("_t", "").strip()
        self.values = values

        # Determine bits per value based on dtype
        if self.dtype == 'int4':
            self.bits = 4
            self.values_per_word = 4  # 8 int4 values per 16-bit word
        elif self.dtype == 'int8':
            self.bits = 8
            self.values_per_word = 2  # 4 int8 values per 16-bit word
        elif self.dtype == 'int16':
            self.bits = 16
            self.values_per_word = 1  # 2 int16 values per 16-bit word
        elif self.dtype == 'int1':
            self.bits = 1
            self.values_per_word = 16
        else:
            raise ValueError(f"Unsupported data type: {self.dtype}")


class HexGenerator:
    def __init__(self, header_path: str, num_banks: int, num_rows: int,
                 addr_offset: int, bank_size: int):
        self.header_path = header_path
        self.num_banks = num_banks
        self.num_rows = num_rows
        self.addr_offset = addr_offset  # In number of 32-bit words
        self.bank_size = bank_size  # Size of each SRAM bank in 32-bit words

        # Calculate columns per row
        self.cols_per_row = self.num_banks // self.num_rows
        if self.num_banks % self.num_rows != 0:
            raise ValueError(
                "Number of banks must be divisible by number of rows")

        # Initialize memory as a 3D structure: [row][col][word]
        # Each element in memory is a 32-bit word (represented as an integer)
        self.memory = [[[0 for _ in range(self.bank_size)]
                       for _ in range(self.cols_per_row)]
                       for _ in range(self.num_rows)]

        # Parse the header file to extract arrays
        self.arrays = self.parse_header_file()

        # Maps array names to their start and end addresses (in bytes)
        self.array_addresses = {}

    def parse_header_file(self) -> List[ArrayInfo]:
        """Parse C header file to extract arrays of data."""
        arrays = []
        array_names = set()  # Track array names to avoid duplicates

        with open(self.header_path, 'r') as f:
            content = f.read()

        # Pattern matches array declarations including const qualifier
        pattern = r'((?:const\s+)?int\d+(?:_t)?)\s+(\w+)(?:\s*\[\s*\d*\s*\])?\s*=\s*\{([^}]*)\};'
        matches = re.findall(pattern, content)

        for dtype, name, values_str in matches:
            # Skip duplicates (arrays with same name but different type)
            if name in array_names:
                continue

            array_names.add(name)

            # Parse values
            values_str = values_str.strip()
            values = []
            if values_str:
                for val in re.split(r',\s*', values_str):
                    if val.strip():
                        try:
                            values.append(int(val.strip(), 0))
                        except ValueError:
                            print(
                                f"Warning: Could not parse value '{val}' in array {name}")

            array_info = ArrayInfo(name, dtype, values)
            arrays.append(array_info)
            print(
                f"Found array: {name}, type: {array_info.dtype}, bits: {array_info.bits}, values: {values[:min(5, len(values))]}...")

        return arrays

    def map_arrays_to_memory(self):
        """Map arrays to memory according to the specified pattern."""
        current_word_addr = self.addr_offset

        for array in self.arrays:
            print(
                f"\nMapping array: {array.name}, type: {array.dtype}, {len(array.values)} values")

            # Record start address for this array (in bytes)
            start_addr = current_word_addr * 2
            # End address will be filled later
            self.array_addresses[array.name] = [start_addr, 0]

            # Start at col determined by current word address
            word_offset = current_word_addr - self.addr_offset
            col = word_offset // self.bank_size
            word = word_offset % self.bank_size

            # Track current position within the 32-bit word for different data types
            if array.dtype == 'int16':
                # For int16, we have 2 values per word (num_rows in LSB half, num_rows in MSB half)
                # Each 32-bit word contains 2 int16 values
                value_index = 0

                while value_index < len(array.values):
                    for part in range(1):  # 0 for LSB, 1 for MSB
                        for row in range(self.num_rows):
                            if value_index < len(array.values):
                                value = array.values[value_index]
                                # Calculate shift amount: 0 for LSB, 16 for MSB
                                shift = part * 16
                                self.memory[row][col][word] |= (
                                    value & 0xFFFF) << shift
                                value_index += 1

                        # After completing all rows for a part, move to next word
                        # but only if we've processed all rows for the current part
                        if part == 0 or value_index >= len(array.values):
                            word += 1
                            if word >= self.bank_size:
                                word = 0
                                col += 1
                                if col >= self.cols_per_row:
                                    raise ValueError(
                                        "Memory capacity exceeded")

            elif array.dtype == 'int8':
                # For int8, we have 4 bytes per word
                # In order: row0-byte0, row1-byte0, ..., rowN-byte0, row0-byte1, ..., rowN-byte3
                value_index = 0

                while value_index < len(array.values):
                    for byte_pos in range(2):  # 4 byte positions in a 32-bit word
                        for row in range(self.num_rows):
                            if value_index < len(array.values):
                                value = array.values[value_index]
                                # Calculate shift amount (0, 8, 16, or 24 bits)
                                shift = byte_pos * 8
                                self.memory[row][col][word] |= (
                                    value & 0xFF) << shift
                                value_index += 1

                        # After completing all rows for a byte position, check if we need to move
                        # to the next word (but only after all byte positions are filled or we're out of values)
                        if byte_pos == 1 or value_index >= len(array.values):
                            word += 1
                            if word >= self.bank_size:
                                word = 0
                                col += 1
                                if col >= self.cols_per_row:
                                    raise ValueError(
                                        "Memory capacity exceeded")

            elif array.dtype == 'int4':
                # For int4, we have 8 nibbles per word
                # In order: row0-nibble0, row1-nibble0, ..., rowN-nibble0, ..., row0-nibble7, ..., rowN-nibble7
                value_index = 0

                while value_index < len(array.values):
                    # 8 nibble positions in a 32-bit word
                    for nibble_pos in range(4):
                        for row in range(self.num_rows):
                            if value_index < len(array.values):
                                value = array.values[value_index]
                                # Calculate shift amount (0, 4, 8, 12, 16, 20, 24, or 28 bits)
                                shift = nibble_pos * 4
                                self.memory[row][col][word] |= (
                                    value & 0xF) << shift
                                value_index += 1

                        # After completing all rows for a nibble position, check if we need to move
                        # to the next word (but only after all nibble positions are filled or we're out of values)
                        if nibble_pos == 3 or value_index >= len(array.values):
                            word += 1
                            if word >= self.bank_size:
                                word = 0
                                col += 1
                                if col >= self.cols_per_row:
                                    raise ValueError(
                                        "Memory capacity exceeded")

            elif array.dtype == 'int1':
                # For int1, we have 16 nibbles per word
                # In order: row0-nibble0, row1-nibble0, ..., rowN-nibble0, ..., row0-nibble7, ..., rowN-nibble7
                value_index = 0

                while value_index < len(array.values):
                    # 16 nibble positions in a 16-bit word
                    for nibble_pos in range(16):
                        for row in range(self.num_rows):
                            if value_index < len(array.values):
                                value = array.values[value_index]
                                # Calculate shift amount (0, 1, 2, 3, 4, ... bits)
                                shift = nibble_pos
                                self.memory[row][col][word] |= (
                                    value & 0x1) << shift
                                value_index += 1

                        # After completing all rows for a nibble position, check if we need to move
                        # to the next word (but only after all nibble positions are filled or we're out of values)
                        if nibble_pos == 15 or value_index >= len(array.values):
                            word += 1
                            if word >= self.bank_size:
                                word = 0
                                col += 1
                                if col >= self.cols_per_row:
                                    raise ValueError(
                                        "Memory capacity exceeded")

            # Update end address and current word address for next array
            # Calculate how many words this array took up
            words_used = 0
            if value_index < len(array.values):
                # Not all values were mapped
                print(
                    f"Warning: Not all values of array {array.name} could be mapped!")

            if word > 0 or col > 0:
                words_used = col * self.bank_size + word

            # If we didn't use any words (empty array), still advance by 1
            if words_used == 0:
                words_used = 1

            current_word_addr = self.addr_offset + words_used
            end_addr = current_word_addr * 2
            self.array_addresses[array.name][1] = end_addr

            print(
                f"Array {array.name} mapped from byte address {start_addr} to {end_addr}")

    def generate_hex_files(self):
        print("")

        """Generate the hex files for each bank."""
        for row in range(self.num_rows):
            for col in range(self.cols_per_row):
                filename = f"neorv32_data32_image_{row}_{col:03d}.hex"
                with open(filename, 'w') as f:
                    for word_idx in range(self.bank_size):
                        word_value = self.memory[row][col][word_idx]
                        # Write as 8-digit hex without '0x' prefix
                        f.write(f"{word_value:04x}\n")
                print(f"Generated file: {filename}")

    def generate_hfai_file(self):
        """Generate the .hfai file with address indexes.

        Each start and end address is multiplied by self.num_rows and displayed
        in hexadecimal notation.
        """
        filename = "arrays.hfai"
        with open(filename, "w") as f:
            # Write header
            f.write("name start stop zero_extensions\n")

            # Process each array address
            for array_name, (start_addr, end_addr) in self.array_addresses.items():
                # Multiply addresses by self.num_rows and convert to hexadecimal strings
                start_hex = f"{start_addr * self.num_rows:#x}"
                end_hex = f"{end_addr * self.num_rows:#x}"
                zero_extensions = 0  # Calculate if needed

                # Write the formatted line to the file
                f.write(
                    f"{array_name} {start_hex} {end_hex} {zero_extensions}\n")

        print(f"Generated file: {filename}")

    def process(self):
        """Process the header file and generate all required outputs."""
        if not self.arrays:
            print(f"Error: No arrays found in header file {self.header_path}")
            return

        self.map_arrays_to_memory()
        self.generate_hex_files()
        self.generate_hfai_file()

        print(
            f"Generated .hfai file and hex files for {len(self.arrays)} arrays.")


def main():
    parser = argparse.ArgumentParser(
        description='Generate hex files for data memory from C header')
    parser.add_argument(
        'header_path', help='Path to the C header file containing arrays')
    parser.add_argument('num_banks', type=int, help='Number of SRAM banks')
    parser.add_argument('num_rows', type=int, help='Number of SRAM rows')
    parser.add_argument('addr_offset', type=int,
                        help='Offset in the address space (in 32-bit words)')
    parser.add_argument('bank_size', type=int,
                        help='Size of each SRAM bank (in 32-bit words)')

    args = parser.parse_args()

    # Create and run the hex generator
    generator = HexGenerator(
        args.header_path,
        args.num_banks,
        args.num_rows,
        args.addr_offset,
        args.bank_size
    )

    generator.process()


if __name__ == "__main__":
    main()
