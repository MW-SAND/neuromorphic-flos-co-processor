#!/usr/bin/env python3
"""
This script has been generated by AI with minor tweaks from the author

C Header File RLC (Run-Length Coding) Processor

This script processes C header files containing weight arrays, applies run-length
encoding to the weights array, and generates a new header file with RLC-encoded
weights and index arrays.

Usage:
    python rlc_processor.py <header_file> <num_pe> <num_neurons>

Where:
    header_file: Path to the input C header file
    num_pe: Number of processing elements
    num_neurons: Number of neurons (used for sub-row splitting)
"""

import re
import sys
import os
from typing import List, Tuple, Dict, Any


def parse_header_file(filepath: str) -> Dict[str, Any]:
    """Parse C header file and extract all array declarations."""
    arrays = {}

    with open(filepath, 'r') as f:
        content = f.read()

    # Pattern to match array declarations
    # Matches: const type_name array_name[size] = { ... };
    pattern = r'const\s+(\w+)\s+(\w+)(?:\[\d*\])?\s*=\s*\{([^}]+)\};'

    matches = re.findall(pattern, content, re.MULTILINE | re.DOTALL)

    for match in matches:
        data_type, array_name, array_data = match

        # Clean and parse array data
        elements = []
        # Remove comments and whitespace, split by commas
        clean_data = re.sub(r'//.*?\n', '', array_data)
        clean_data = re.sub(r'/\*.*?\*/', '', clean_data, flags=re.DOTALL)

        for element in clean_data.split(','):
            element = element.strip()
            if element:
                try:
                    # Handle hex values and regular integers
                    if element.startswith('0x') or element.startswith('0X'):
                        elements.append(int(element, 16))
                    else:
                        elements.append(int(element))
                except ValueError:
                    continue

        arrays[array_name] = {
            'type': data_type,
            'data': elements
        }

    return arrays


def split_weights_into_rows(weights: List[int], num_pe: int) -> List[List[int]]:
    """Split weights into rows by distributing them among processing elements using round-robin."""
    pe_rows = [[] for _ in range(num_pe)]

    for i, weight in enumerate(weights):
        pe_idx = i % num_pe
        pe_rows[pe_idx].append(weight)

    return pe_rows


def split_row_into_subrows(row: List[int], neurons_per_pe: int) -> List[List[int]]:
    """Split a row into sub-rows based on the number of neurons per PE."""
    if not row:
        return []

    subrows = []
    for i in range(0, len(row), neurons_per_pe):
        subrow = row[i:i + neurons_per_pe]
        subrows.append(subrow)

    return subrows


def run_length_encode(subrow: List[int], neurons_per_pe) -> List[int]:
    """Apply run-length coding to a sub-row of weights.

    Returns:
        encoded: RLC encoded array [count, value, count, value, ...]
    """
    if not subrow:
        return []

    encoded = []
    i = 0
    total_rlc_count = 0

    while i < len(subrow):
        if subrow[i] == 0:
            # Count consecutive zeros
            zero_count = 0
            while i < len(subrow) and subrow[i] == 0:
                zero_count += 1
                i += 1

            # split into 15-count chunks for any 14 zeros
            # (15 represents 14 zeros + one weight slot)
            while zero_count > 14:
                encoded.extend([15, 0])
                total_rlc_count += 15
                zero_count -= 15

            # Add RLC count and the following non-zero value
            if i < len(subrow):  # There's a non-zero value after zeros
                encoded.extend([zero_count+1, subrow[i]])
                total_rlc_count += zero_count+1
                i += 1
            else:  # Zeros at the end
                encoded.extend([zero_count, 0])
                total_rlc_count += zero_count
        else:
            # Non-zero value, add RLC count of 0 and the value
            encoded.extend([1, subrow[i]])
            total_rlc_count += 1
            i += 1

    return encoded


def add_termination_markers(encoded_subrow: List[int]) -> List[int]:
    """Add termination markers (0, 0) and ensure the array length is a multiple of 4."""
    result = encoded_subrow.copy()

    # Add termination marker
    result.extend([0, 0])

    # Ensure length is multiple of 4 by adding additional (0, 0) pairs if needed
    while len(result) % 4 != 0:
        result.extend([0, 0])

    return result


def calculate_indexes(pe_subrows: List[List[List[int]]], num_pe: int) -> List[int]:
    """Calculate index array by finding positions of termination markers (0, 0) pairs."""
    # Calculate indices for each PE separately
    pe_indices = []

    for pe_idx in range(num_pe):
        pe_index_list = []
        current_pos = 0
        for subrow_idx, subrow in enumerate(pe_subrows[pe_idx]):
            # Add index for this subrow (position divided by 4*num_pe)
            pe_index_list.append(current_pos // 4)
            current_pos += len(subrow)
            # if pe_idx == 0:
            #     print(f"{subrow_idx} has {len(subrow)} elements")
        pe_indices.append(pe_index_list)

    # Interleave the indices across PEs
    interleaved_indices = interleave_arrays(pe_indices, False)

    return interleaved_indices


def postprocess_index_array(index_array: List[int], num_pe: int) -> List[int]:
    """Postprocess the index array by adding n - (index_position // NPE_COUNT) to each index.

    Args:
        index_array: The original index array
        num_pe: Number of processing elements (NPE_COUNT)

    Returns:
        List[int]: The postprocessed index array
    """
    if len(index_array) % num_pe != 0:
        print(
            f"Warning: Index array length ({len(index_array)}) is not evenly divisible by PE count ({num_pe})")

    n = len(index_array) // num_pe
    postprocessed_array = []

    for i, index_value in enumerate(index_array):
        increment = n - (i // num_pe)
        new_value = index_value + increment
        postprocessed_array.append(new_value)

    return postprocessed_array


def interleave_arrays(arrays: List[List[int]], print_padding: bool = False) -> List[int]:
    """Interleave multiple arrays element by element."""
    if not arrays:
        return []

    # Pad arrays to same length
    max_len = max(len(arr) for arr in arrays)
    padded_arrays = []

    for i, arr in enumerate(arrays):
        padded_arr = arr.copy()
        padding_needed = max_len - len(arr)
        if print_padding and padding_needed > 0:
            print(f"Padding PE row {i} with {padding_needed} elements")
        padded_arr.extend([0] * padding_needed)
        padded_arrays.append(padded_arr)

    # Interleave
    interleaved = []
    for i in range(max_len):
        for arr in padded_arrays:
            interleaved.append(arr[i])

    return interleaved


def format_array_line(array_name: str, data_type: str, data: List[int]) -> str:
    """Format an array as a single line C declaration."""
    data_str = ', '.join(map(str, data))
    return f"const {data_type} {array_name}[{len(data)}] = {{ {data_str} }};"


def process_weights(weights: List[int], num_pe: int, num_neurons: int) -> Tuple[List[int], List[int]]:
    """Process weights array through the complete RLC pipeline."""

    # Calculate neurons per PE
    neurons_per_pe = num_neurons // num_pe
    print(f"Neurons per PE: {neurons_per_pe}")

    # Step 1: Split weights into rows (distribute among PEs)
    print("Step 1: Splitting weights into PE rows...")
    pe_weight_rows = split_weights_into_rows(weights, num_pe)

    for i, row in enumerate(pe_weight_rows):
        print(f"PE {i}: {len(row)} weights")

    # Step 2: Split each row into sub-rows
    print("\nStep 2: Splitting rows into sub-rows...")
    pe_subrows = []

    for i, row in enumerate(pe_weight_rows):
        subrows = split_row_into_subrows(row, neurons_per_pe)
        pe_subrows.append(subrows)
        print(f"PE {i}: Split into {len(subrows)} sub-rows")

    # Step 3: Apply RLC encoding to each sub-row
    print("\nStep 3: Applying RLC encoding...")
    pe_encoded_subrows = []

    for i, subrows in enumerate(pe_subrows):
        encoded_subrows = []
        for j, subrow in enumerate(subrows):
            encoded = run_length_encode(subrow, neurons_per_pe)
            encoded_subrows.append(encoded)
            # print(f"PE {i}, Sub-row {j}: {len(subrow)} -> {len(encoded)} elements")
        pe_encoded_subrows.append(encoded_subrows)

    # Step 4: Add termination markers and padding
    print("\nStep 4: Adding termination markers and padding...")
    pe_final_subrows = []

    for i, encoded_subrows in enumerate(pe_encoded_subrows):
        final_subrows = []
        for j, encoded_subrow in enumerate(encoded_subrows):
            final_subrow = add_termination_markers(encoded_subrow)
            final_subrows.append(final_subrow)
            # print(f"PE {i}, Sub-row {j}: {len(encoded_subrow)} -> {len(final_subrow)} elements (with termination)")
        pe_final_subrows.append(final_subrows)

    # Step 5: Calculate indexes
    print("\nStep 5: Calculating indexes...")
    index_array = calculate_indexes(pe_final_subrows, num_pe)
    index_array = postprocess_index_array(index_array, num_pe)
    print(f"Index array: {len(index_array)} elements")

    # Step 6: Flatten sub-rows for each PE
    print("\nStep 6: Flattening sub-rows...")
    pe_flattened_rows = []

    for i, final_subrows in enumerate(pe_final_subrows):
        flattened_row = []
        for subrow in final_subrows:
            flattened_row.extend(subrow)
        pe_flattened_rows.append(flattened_row)
        print(f"PE {i}: Flattened to {len(flattened_row)} elements")

    # Step 7: Interleave across PEs
    print("\nStep 7: Interleaving across PEs...")
    interleaved_weights = interleave_arrays(pe_flattened_rows, True)

    print(f"Final interleaved weights: {len(interleaved_weights)} elements")
    print(f"Index array: {len(index_array)} elements")

    return interleaved_weights, index_array


def main():
    if len(sys.argv) != 4:
        print("Usage: python rlc_processor.py <header_file> <num_pe> <num_neurons>")
        sys.exit(1)

    header_file = sys.argv[1]
    num_pe = int(sys.argv[2])
    num_neurons = int(sys.argv[3])

    # Validate inputs
    if not os.path.exists(header_file):
        print(f"Error: Header file '{header_file}' not found.")
        sys.exit(1)

    if num_pe <= 0 or num_neurons <= 0:
        print("Error: Number of PEs and neurons must be positive integers.")
        sys.exit(1)

    if num_neurons % num_pe != 0:
        print(
            f"Warning: Number of neurons ({num_neurons}) is not evenly divisible by PE count ({num_pe})")

    # Parse input header file
    print(f"Processing header file: {header_file}")
    arrays = parse_header_file(header_file)

    if not arrays:
        print("Error: No arrays found in header file.")
        sys.exit(1)

    # Find weights array (look for common weight array names)
    weight_array_name = None
    weight_array_data = None

    for name, info in arrays.items():
        if 'weight' in name.lower():
            weight_array_name = name
            weight_array_data = info
            break

    if weight_array_name is None:
        print("Error: No weight array found in header file.")
        print("Available arrays:", list(arrays.keys()))
        sys.exit(1)

    print(
        f"Found weight array: {weight_array_name} with {len(weight_array_data['data'])} elements")

    # Process weights
    weights = weight_array_data['data']
    if len(weights) % num_pe != 0:
        print(
            f"Warning: Weight array length ({len(weights)}) is not evenly divisible by PE count ({num_pe})")

    rlc_weights, index_array = process_weights(weights, num_pe, num_neurons)

    # Generate output filename
    base_name = os.path.splitext(header_file)[0]
    output_file = f"{base_name}_rlc.h"

    # Write output file
    print(f"\nWriting output to: {output_file}")

    with open(output_file, 'w') as f:
        f.write("// Auto-generated RLC-processed header file\n")
        f.write(f"// Original file: {header_file}\n")
        f.write(
            f"// Processing parameters: PE={num_pe}, Neurons={num_neurons}\n\n")

        # Write all original arrays except weights (single line format)
        for name, info in arrays.items():
            if name != weight_array_name:  # Skip original weights array
                line = format_array_line(name, info['type'], info['data'])
                f.write(line + '\n')

        # Write index array
        index_line = format_array_line(
            f"{weight_array_name}_index", "int16_t", index_array)
        f.write(index_line + "\n")

        # Write RLC-encoded weights array
        rlc_line = format_array_line(
            f"{weight_array_name}_rlc", "int4_t", rlc_weights)
        f.write(rlc_line + "\n")

    print(f"Successfully generated {output_file}")
    print(f"Original weights: {len(weights)} elements")
    print(f"RLC weights: {len(rlc_weights)} elements")
    print(f"Index array: {len(index_array)} elements")


if __name__ == "__main__":
    main()
